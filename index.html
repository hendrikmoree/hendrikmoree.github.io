<!DOCTYPE html>
<html lang="nl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#f0f8ff">
    <!-- Cache control -->
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <!-- Version number -->
    <meta name="version" content="1.0.1">
    <title>Tafels Oefenen</title>
    <style>
        * {
            -webkit-tap-highlight-color: transparent;
            -webkit-touch-callout: none;
            touch-action: manipulation;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            background-color: #fafafa;
            margin: 0;
            padding: 10px;
            text-align: center;
            color: #333;
            min-height: 100vh;
            min-height: -webkit-fill-available;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            overflow-x: hidden;
            -webkit-overflow-scrolling: touch;
        }

        /* Prevent iOS zoom on input */
        input, select, textarea {
            font-size: 16px;
        }

        h1 {
            color: #ff6b6b;
            font-size: 1.8rem;
            margin-bottom: 0.5rem;
        }

        h2 {
            color: #4ecdc4;
            font-size: 1.3rem;
            margin-bottom: 0.5rem;
        }

        .container {
            background-color: white;
            border-radius: 20px;
            padding: 15px;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
            max-width: 600px;
            width: calc(100% - 20px);
            margin: 0 auto;
            box-sizing: border-box;
        }

        button {
            background-color: #ff9a3c;
            border: none;
            border-radius: 10px;
            color: white;
            padding: 12px 24px;
            margin: 8px 4px;
            font-size: 1.1rem;
            cursor: pointer;
            transition: transform 0.2s, background-color 0.3s;
            min-height: 44px;
            min-width: 44px;
            user-select: none;
            -webkit-user-select: none;
        }

        button:active {
            transform: scale(0.95);
        }

        button.selected {
            background-color: #43aa8b;
            transform: scale(1.05);
        }

        .question {
            font-size: 2rem;
            margin: 15px 0;
            color: #ff6b6b;
            word-wrap: break-word;
        }

        .options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            padding: 10px;
        }

        .option {
            background-color: #4ecdc4;
            font-size: 1.5rem;
            padding: 15px;
            border-radius: 10px;
            transition: transform 0.2s, filter 0.3s;
            min-height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .option:active {
            transform: scale(0.95);
        }

        .screen-section {
            margin: 15px 0;
            display: none;
            width: 100%;
        }

        #gameScreen {
            position: relative;
        }

        .score-display {
            font-size: 1.3rem;
            margin: 8px 0;
            color: #ff6b6b;
        }

        .high-score {
            font-size: 1.1rem;
            margin: 8px 0;
            color: #43aa8b;
        }

        .progress-bar {
            height: 15px;
            width: 100%;
            background-color: #eee;
            border-radius: 8px;
            margin: 12px 0;
            overflow: hidden;
        }

        .progress {
            height: 100%;
            background-color: #ff9a3c;
            width: 0%;
            transition: width 0.5s;
        }

        .emoji {
            font-size: 1.8rem;
            margin: 8px 0;
        }

        .timer {
            font-size: 1.1rem;
            color: #ff6b6b;
            margin: 8px 0;
        }

        .result-message {
            font-size: 1.3rem;
            margin: 15px 0;
            font-weight: bold;
            opacity: 0;
            transform: translateY(20px);
            transition: opacity 0.5s, transform 0.5s;
        }

        .result-message.show {
            opacity: 1;
            transform: translateY(0);
        }

        .correct {
            color: #43aa8b;
        }

        .wrong {
            color: #ff6b6b;
        }

        .highscore-table {
            width: 100%;
            border-collapse: collapse;
            margin: 12px 0;
            font-size: 0.9rem;
        }

        .highscore-table th, .highscore-table td {
            padding: 8px;
            text-align: center;
            border-bottom: 1px solid #ddd;
        }

        .delete-score-btn {
            padding: 0;
            width: 24px;
            height: 24px;
            font-size: 16px;
            margin: 0;
            min-height: unset;
            border-radius: 6px;
            background-color: #ff6b6b;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s ease;
            opacity: 0.8;
        }

        .delete-score-btn:hover {
            opacity: 1;
            transform: scale(1.1);
            background-color: #ff5252;
        }

        .delete-score-btn:active {
            transform: scale(0.95);
        }

        @media (max-width: 480px) {
            .container {
                padding: 10px;
            }

            button {
                padding: 10px 20px;
                font-size: 1rem;
                margin: 5px 2px;
            }

            .question {
                font-size: 1.8rem;
            }

            .option {
                font-size: 1.3rem;
                padding: 12px;
            }

            .highscore-table {
                font-size: 0.8rem;
            }

            .highscore-table th, .highscore-table td {
                padding: 6px;
            }

            h1 {
                font-size: 1.6rem;
            }

            h2 {
                font-size: 1.2rem;
            }

            .delete-score-btn {
                width: 20px;
                height: 20px;
                font-size: 14px;
            }
        }

        @media (max-width: 360px) {
            .container {
                padding: 8px;
            }

            button {
                padding: 8px 16px;
                font-size: 0.9rem;
            }

            .question {
                font-size: 1.6rem;
            }

            .option {
                font-size: 1.2rem;
                padding: 10px;
            }
        }

        /* Fix for iOS height issues */
        @supports (-webkit-touch-callout: none) {
            body {
                min-height: -webkit-fill-available;
            }
        }

        /* Improved touch feedback */
        @media (hover: hover) {
            button:hover {
                background-color: #ff7b00;
                transform: scale(1.05);
            }

            .option:hover {
                transform: scale(1.1);
                filter: brightness(1.2);
            }
        }

        .result-emoji {
            font-size: 4rem;
            margin: 10px 0;
        }

        .result-details {
            background-color: #f8f9fa;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            width: 100%;
            max-width: 400px;
        }

        .score-item {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
        }

        .score-item:last-child {
            border-bottom: none;
        }

        .score-label {
            font-weight: 500;
            color: #495057;
        }

        .score-value {
            font-weight: 600;
            color: #212529;
        }

        .total-score {
            margin-top: 15px;
            padding-top: 10px;
            border-top: 2px solid #dee2e6;
            font-size: 1.2rem;
        }

        .total-score .score-value {
            color: #007bff;
            font-weight: 700;
        }

        /* Format for the time display */
        #timer, #finalTime {
            font-family: 'Courier New', monospace;
            font-weight: 600;
        }

        /* Sterren stijlen */
        .stars-container {
            margin: 10px 0;
            display: flex;
            justify-content: center;
            gap: 5px;
        }

        .star {
            font-size: 2rem;
            color: #ccc;
            transition: color 0.3s, transform 0.5s;
        }

        .star.earned {
            color: gold;
            animation: starPulse 0.5s ease-in-out;
        }

        @keyframes starPulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.3); }
            100% { transform: scale(1); }
        }

        /* Confetti stijlen */
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: #f00;
            opacity: 0;
            z-index: 100;
        }

        /* Streak counter */
        .streak-counter {
            font-size: 1rem;
            color: #ff9a3c;
            margin: 5px 0;
            font-weight: bold;
        }

        /* Animatie voor correcte antwoorden */
        @keyframes correctAnswer {
            0% { transform: scale(1); }
            50% { transform: scale(1.1); }
            100% { transform: scale(1); }
        }

        .animate-correct {
            animation: correctAnswer 0.5s ease-in-out;
        }

        .button-group {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
            width: 100%;
            max-width: 400px;
        }

        .button-group button {
            flex: 1;
            font-size: 1.1rem;
            padding: 12px 25px;
        }

        @media (max-width: 480px) {
            .button-group {
                flex-direction: column;
                align-items: center;
            }

            .button-group button {
                width: 100%;
            }
        }

        .menu-button {
            background-color: #4ecdc4;
        }

        .menu-button:hover {
            background-color: #3db5ae;
        }

        /* Pauzeknop stijlen */
        .pause-button {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: transparent;
            color: #4ecdc4;
            border: none;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.3s;
            z-index: 10;
        }

        .pause-button:hover {
            background-color: transparent;
            color: #3db5ae;
            transform: scale(1.1);
        }

        /* Pauzemenu stijlen */
        #pauseMenu {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.95);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 5;
            border-radius: 20px;
        }

        #pauseMenu h2 {
            margin-bottom: 20px;
        }

        #pauseMenu button {
            margin: 10px;
            min-width: 200px;
        }

        /* Stijl voor uitgeschakelde knoppen */
        button:disabled {
            background-color: #cccccc;
            color: #666666;
            cursor: not-allowed;
            transform: none;
        }

        /* Stijl voor de selectie-instructie */
        .selection-instruction {
            color: #ff6b6b;
            font-size: 0.9rem;
            margin: 10px 0;
            padding: 5px;
            border-radius: 5px;
            background-color: #fff5f5;
            display: none;
        }

        #resultScreen {
            display: none;
            width: 100%;
        }

        #resultScreen.screen-section {
            flex-direction: column;
            align-items: center;
        }

        #resultScreen[style*="display: flex"] {
            display: flex !important;
            flex-direction: column;
            align-items: center;
        }

        .result-emoji {
            font-size: 4rem;
            margin: 10px 0;
        }

        /* Badge systeem stijlen */
        .badges-screen {
            display: none;
            padding: 20px 0;
            text-align: center;
            width: 100%;
        }

        .badges-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
            padding: 20px;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            box-sizing: border-box;
        }

        .badge {
            background: white;
            border-radius: 15px;
            padding: 15px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            text-align: center;
            transition: transform 0.3s;
            position: relative;
            margin: 0 auto;
            width: 100%;
            max-width: 200px;
            box-sizing: border-box;
        }

        .badge.locked {
            filter: grayscale(1);
            opacity: 0.7;
        }

        .badge:hover {
            transform: translateY(-5px);
        }

        .badge-icon {
            font-size: 3rem;
            margin-bottom: 10px;
        }

        .badge-title {
            font-weight: bold;
            color: #333;
            margin: 5px 0;
        }

        .badge-description {
            font-size: 0.9rem;
            color: #666;
            margin: 5px 0;
        }

        .badge-progress {
            font-size: 0.8rem;
            color: #43aa8b;
            margin-top: 5px;
        }

        .badge-notification {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: #43aa8b;
            color: white;
            padding: 15px 30px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.2);
            display: none;
            z-index: 1000;
            animation: slideUp 0.5s ease-out;
        }

        @keyframes slideUp {
            from {
                transform: translate(-50%, 100%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        .view-badges-btn {
            position: absolute;
            top: 2px;
            right: 2px;
            width: 28px;
            height: 28px;
            border-radius: 50%;
            padding: 0;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0;
            background-color: #f0f0f0;
            color: #666;
        }

        @media (max-width: 480px) {
            .view-badges-btn {
                width: 20px;
                height: 20px;
                font-size: 12px;
                top: 2px;
                right: 2px;
            }
        }

        /* Badge unlock animatie */
        @keyframes unlockBadge {
            0% { transform: scale(1); }
            50% { transform: scale(1.2); }
            100% { transform: scale(1); }
        }

        .badge.unlocking {
            animation: unlockBadge 0.5s ease-out;
        }

        #selectionScreen {
            position: relative;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="selectionScreen" class="screen-section" style="display: block;">
            <h1>Tafels Oefenen</h1>

            <h2>Welke tafels wil je oefenen?</h2>
            <div id="tafelButtons">
                <button class="tafel-btn" data-tafel="1">Tafel van 1</button>
                <button class="tafel-btn" data-tafel="2">Tafel van 2</button>
                <button class="tafel-btn" data-tafel="3">Tafel van 3</button>
                <button class="tafel-btn" data-tafel="4">Tafel van 4</button>
                <button class="tafel-btn" data-tafel="5">Tafel van 5</button>
                <button class="tafel-btn" data-tafel="6">Tafel van 6</button>
                <button class="tafel-btn" data-tafel="7">Tafel van 7</button>
                <button class="tafel-btn" data-tafel="8">Tafel van 8</button>
                <button class="tafel-btn" data-tafel="9">Tafel van 9</button>
                <button class="tafel-btn" data-tafel="10">Tafel van 10</button>
            </div>
            <h2>Hoeveel vragen wil je beantwoorden?</h2>
            <div id="questionCountButtons">
                <button class="question-count-btn" data-count="5">5 vragen</button>
                <button class="question-count-btn" data-count="10">10 vragen</button>
                <button class="question-count-btn" data-count="15">15 vragen</button>
                <button class="question-count-btn" data-count="20">20 vragen</button>
            </div>
            <div>
                <button id="startButton" disabled>Start!</button>
            </div>
            <button class="view-badges-btn" onclick="showScreen('badgesScreen')">🏆</button>
            <div class="high-score">
                <h3>Highscores</h3>
                <p style="font-size: 0.9rem; color: #666; margin-bottom: 10px;">Score = % goed × tijdbonus</p>
                <table class="highscore-table">
                    <thead>
                        <tr>
                            <th>Datum</th>
                            <th>Tafels</th>
                            <th>Score</th>
                            <th>Tijd</th>
                            <th></th>
                        </tr>
                    </thead>
                    <tbody id="highscoreTable">
                        <!-- Highscores will be added here -->
                    </tbody>
                </table>
            </div>
        </div>

        <div id="gameScreen" class="screen-section">
            <button id="pauseButton" class="pause-button" title="Pauze">⏸️</button>
            <div class="score-display">
                Score: <span id="currentScore">0</span> / <span id="totalQuestions">0</span>
            </div>
            <div class="stars-container" id="starsContainer">
                <!-- Sterren worden hier dynamisch toegevoegd -->
            </div>
            <div class="streak-counter" id="streakCounter">Reeks: 0</div>
            <div class="progress-bar">
                <div class="progress" id="progressBar"></div>
            </div>
            <div class="timer" id="timer">Tijd: 0 seconden</div>
            <div class="question" id="question"></div>
            <div class="options" id="options"></div>
            <div class="result-message" id="resultMessage"></div>
            <div class="emoji" id="emoji"></div>

            <!-- Pauzemenu -->
            <div id="pauseMenu">
                <h2>Pauze</h2>
                <button id="resumeButton">Doorgaan</button>
                <button id="quitButton" class="menu-button">Terug naar menu</button>
            </div>
        </div>

        <div id="resultScreen" class="screen-section">
            <h2>Resultaat</h2>
            <div id="resultEmoji" class="result-emoji">😃</div>
            <div class="result-details">
                <div class="score-item">
                    <span class="score-label">Score:</span>
                    <span id="finalScore" class="score-value">0/0</span>
                </div>
                <div class="score-item">
                    <span class="score-label">Percentage:</span>
                    <span id="percentageScore" class="score-value">0%</span>
                </div>
                <div class="score-item">
                    <span class="score-label">Tijd:</span>
                    <span id="finalTime" class="score-value">0:00</span>
                </div>
                <div class="score-item">
                    <span class="score-label">Tijdbonus:</span>
                    <span id="timeBonus" class="score-value">-</span>
                </div>
                <div class="score-item total-score">
                    <span class="score-label">Totaalscore:</span>
                    <span id="combinedScore" class="score-value">0</span>
                </div>
            </div>
            <div class="button-group">
                <button id="playAgainButton" class="button">Nog een keer!</button>
                <button id="menuButton" class="button menu-button">Terug naar menu</button>
            </div>
        </div>

        <div id="badgesScreen" class="screen-section badges-screen">
            <h2>Mijn Badges</h2>
            <div class="badges-grid" id="badgesGrid">
                <!-- Badges worden hier dynamisch toegevoegd -->
            </div>
            <button class="menu-button" onclick="showScreen('selectionScreen')">Terug naar menu</button>
        </div>

        <div class="badge-notification" id="badgeNotification">
            <!-- Badge meldingen verschijnen hier -->
        </div>
    </div>

    <script>
        // Initialization
        let selectedTables = [];
        let questionCount = 0;
        let currentQuestion = 0;
        let score = 0;
        let startTime;
        let timerInterval;
        let highscores = JSON.parse(localStorage.getItem('tafelsHighscores')) || [];
        let currentTafelSet = [];
        let questions = [];
        let currentStreak = 0;
        let maxStreak = 0;
        let isPaused = false;
        let pauseStartTime;
        let totalPausedTime = 0;

        // Badge systeem
        const BADGES = {
            SPEED_DEMON: {
                id: 'speed-demon',
                icon: '⚡',
                title: 'Supersnel',
                description: 'Beantwoord 10 vragen binnen 30 seconden',
                condition: (stats) => stats.avgTimePerQuestion < 3,
                progress: (stats) => {
                    if (stats.avgTimePerQuestion >= 3) return Math.min(100, Math.round((3 / stats.avgTimePerQuestion) * 100))
                    return 100 // If avgTimePerQuestion is less than 3, progress is 100%
                }
            },
            PERFECT_SCORE: {
                id: 'perfect-score',
                icon: '🏆',
                title: 'Perfect!',
                description: 'Behaal een 100% score',
                condition: (stats) => stats.percentageScore === 100,
                progress: (stats) => stats.percentageScore
            },
            STREAK_MASTER: {
                id: 'streak-master',
                icon: '🔥',
                title: 'Reeksmeester',
                description: 'Behaal een reeks van 10 goede antwoorden',
                condition: (stats) => stats.maxStreak >= 10,
                progress: (stats) => Math.min(100, (stats.maxStreak / 10) * 100)
            },
            TABLE_MASTER: {
                id: 'table-master',
                icon: '🎓',
                title: 'Tafelmeester',
                description: 'Beantwoord van elke tafel minstens één som goed',
                condition: (stats) => stats.correctTablesPlayed.size >= 10,
                progress: (stats) => Math.round((stats.correctTablesPlayed.size / 10) * 100)
            },
            DEDICATION: {
                id: 'dedication',
                icon: '🌟',
                title: 'Toegewijd',
                description: 'Speel 5 spellen achter elkaar',
                condition: (stats) => stats.gamesPlayed >= 5,
                progress: (stats) => Math.min(100, (stats.gamesPlayed / 5) * 100)
            },
            SPEED_MASTER: {
                id: 'speed-master',
                icon: '🚀',
                title: 'Snelheidsmeester',
                description: 'Behaal een perfecte score binnen 30 seconden (10 vragen)',
                condition: (stats) => stats.percentageScore === 100 && stats.avgTimePerQuestion < 3,
                progress: (stats) => stats.percentageScore === 100 ? Math.min(100, Math.round((3 / stats.avgTimePerQuestion) * 100)) : 0
            },
            MARATHON_MASTER: {
                id: 'marathon-master',
                icon: '🏃',
                title: 'Marathonmeester',
                description: 'Behaal een perfecte score met 5 verschillende tafels (10 vragen)',
                condition: (stats) => {
                    return stats.percentageScore === 100 && stats.lastSelectedTables?.length >= 5 && stats.totalQuestions >= 10;
                },
                progress: (stats) => {
                    return stats.percentageScore === 100 && stats.totalQuestions >= 10 ? Math.min(100, ((stats.lastSelectedTables?.length || 0) / 5) * 100) : 0;
                }
            },
            ULTIMATE_STREAK: {
                id: 'ultimate-streak',
                icon: '⭐',
                title: 'Ultieme Reeks',
                description: 'Behaal een reeks van 20 goede antwoorden',
                condition: (stats) => stats.maxStreak >= 20,
                progress: (stats) => Math.min(100, (stats.maxStreak / 20) * 100)
            },
            GRANDMASTER: {
                id: 'grandmaster',
                icon: '👑',
                title: 'Grootmeester',
                description: 'Behaal 3 perfecte scores achter elkaar',
                condition: (stats) => stats.perfectScoreStreak >= 3,
                progress: (stats) => Math.min(100, (stats.perfectScoreStreak / 3) * 100)
            }
        };

        // Laad behaalde badges uit localStorage
        let earnedBadges = JSON.parse(localStorage.getItem('earnedBadges')) || {};
        let gameStats = JSON.parse(localStorage.getItem('gameStats')) || {
            gamesPlayed: 0,
            uniqueTablesPlayed: [],
            correctTablesPlayed: [],
            fastestGame: Infinity,
            highestStreak: 0,
            perfectScoreStreak: 0,
            lastSelectedTables: [],
            totalQuestions: 0
        };

        // Convert Arrays to Sets
        gameStats.uniqueTablesPlayed = new Set(gameStats.uniqueTablesPlayed || []);
        gameStats.correctTablesPlayed = new Set(gameStats.correctTablesPlayed || []);

        // DOM Elements
        const selectionScreen = document.getElementById('selectionScreen');
        const gameScreen = document.getElementById('gameScreen');
        const resultScreen = document.getElementById('resultScreen');
        const pauseMenu = document.getElementById('pauseMenu');
        const pauseButton = document.getElementById('pauseButton');
        const resumeButton = document.getElementById('resumeButton');
        const quitButton = document.getElementById('quitButton');
        const tafelButtons = document.querySelectorAll('.tafel-btn');
        const questionCountButtons = document.querySelectorAll('.question-count-btn');
        const startButton = document.getElementById('startButton');
        const questionElement = document.getElementById('question');
        const optionsElement = document.getElementById('options');
        const currentScoreElement = document.getElementById('currentScore');
        const totalQuestionsElement = document.getElementById('totalQuestions');
        const finalScoreElement = document.getElementById('finalScore');
        const finalTotalQuestionsElement = document.getElementById('finalTotalQuestions');
        const progressBar = document.getElementById('progressBar');
        const timerElement = document.getElementById('timer');
        const finalTimeElement = document.getElementById('finalTime');
        const resultMessageElement = document.getElementById('resultMessage');
        const emojiElement = document.getElementById('emoji');
        const resultEmojiElement = document.getElementById('resultEmoji');
        const highscoreMessageElement = document.getElementById('highscore-message');
        const playAgainButton = document.getElementById('playAgainButton');
        const highscoreTable = document.getElementById('highscoreTable');

        // Initialize highscore table
        updateHighscoreTable();

        // Event Listeners
        tafelButtons.forEach(button => {
            button.addEventListener('click', () => {
                button.classList.toggle('selected');
                const tafel = parseInt(button.dataset.tafel);

                if (button.classList.contains('selected')) {
                    if (!selectedTables.includes(tafel)) {
                        selectedTables.push(tafel);
                    }
                } else {
                    const index = selectedTables.indexOf(tafel);
                    if (index !== -1) {
                        selectedTables.splice(index, 1);
                    }
                }

                updateStartButtonState();
                updateHighscoreTable();
            });
        });

        questionCountButtons.forEach(button => {
            button.addEventListener('click', () => {
                questionCountButtons.forEach(btn => btn.classList.remove('selected'));
                button.classList.add('selected');
                questionCount = parseInt(button.dataset.count);
                updateStartButtonState();
            });
        });

        startButton.addEventListener('click', startGame);
        playAgainButton.addEventListener('click', () => {
            resultScreen.style.display = 'none';
            startGame();
        });

        document.getElementById('menuButton').addEventListener('click', () => {
            resultScreen.style.display = 'none';
            selectionScreen.style.display = 'block';

            tafelButtons.forEach(button => {
                button.classList.remove('selected');
            });
            questionCountButtons.forEach(button => {
                button.classList.remove('selected');
            });
            selectedTables = [];
            questionCount = 0;

            updateStartButtonState();
            updateHighscoreTable();
        });

        pauseButton.addEventListener('click', pauseGame);
        resumeButton.addEventListener('click', resumeGame);
        quitButton.addEventListener('click', quitGame);

        // Functions
        function updateStartButtonState() {
            startButton.disabled = selectedTables.length === 0 || questionCount === 0;
        }

        function formatFriendlyDate(dateString) {
            let date
            // Check if the date is in ISO format or old local format
            if (dateString.includes('T')) {
                // ISO format
                date = new Date(dateString)
            } else {
                // Old format (local date string)
                const [day, month, year] = dateString.split('-')
                date = new Date(year, month - 1, day)
            }

            const now = new Date()
            const diffTime = Math.abs(now - date)
            const diffDays = Math.floor(diffTime / (1000 * 60 * 60 * 24))

            if (diffDays === 0) return 'vandaag'
            if (diffDays === 1) return 'gisteren'
            if (diffDays < 7) return `${diffDays} dagen geleden`
            if (diffDays < 14) return 'vorige week'
            if (diffDays < 30) return 'deze maand'
            return 'lang geleden'
        }

        // Migrate existing scores to new date format
        function migrateScores() {
            const keys = Object.keys(localStorage).filter(key => key.startsWith('highscores-'))
            keys.forEach(key => {
                const scores = JSON.parse(localStorage.getItem(key)) || []
                const updatedScores = scores.map(score => {
                    if (!score.date.includes('T')) {  // If not in ISO format
                        const [day, month, year] = score.date.split('-')
                        const date = new Date(year, month - 1, day)
                        score.date = date.toISOString()
                    }
                    return score
                })
                localStorage.setItem(key, JSON.stringify(updatedScores))
            })
        }

        // Run migration when page loads
        migrateScores()

        function updateHighscoreTable() {
            highscoreTable.innerHTML = '';

            // Voeg een titel toe die aangeeft welke tafels worden getoond
            const highscoreTitle = document.querySelector('.high-score h3');

            if (selectedTables.length === 0) {
                highscoreTitle.textContent = 'Highscores (alle tafels)';
            } else {
                const tafelNummers = selectedTables.sort((a, b) => a - b).join(', ');
                highscoreTitle.textContent = `Highscores (tafel van ${tafelNummers})`;
            }

            // Get highscores for the current table selection or all highscores if no selection
            let allHighscores = [];

            if (selectedTables.length === 0) {
                // No tables selected, show all highscores from all table sets
                const keys = Object.keys(localStorage).filter(key => key.startsWith('highscores-'));
                keys.forEach(key => {
                    const scores = JSON.parse(localStorage.getItem(key)) || [];
                    scores.forEach(score => {
                        // Voeg de tafelset toe aan elk score object voor weergave
                        score.tafelSet = key.replace('highscores-', '');
                        allHighscores.push(score);
                    });
                });
            } else {
                // Tables selected, show only those highscores
                const tableKey = selectedTables.sort().join('-');
                const scores = JSON.parse(localStorage.getItem(`highscores-${tableKey}`)) || [];
                scores.forEach(score => {
                    // Voeg de tafelset toe aan elk score object voor weergave
                    score.tafelSet = tableKey;
                    allHighscores.push(score);
                });
            }

            // Ensure each highscore has a combinedScore
            allHighscores = allHighscores.map(score => {
                if (!score.combinedScore) {
                    // Calculate percentage score
                    const percentageScore = Math.round((score.score / score.totalQuestions) * 100);

                    // Calculate average time per question
                    const avgTimePerQuestion = score.time / score.totalQuestions;

                    // Determine time bonus
                    let timeBonus = 1.0;
                    if (avgTimePerQuestion < 3) timeBonus = 1.5;
                    else if (avgTimePerQuestion < 5) timeBonus = 1.3;
                    else if (avgTimePerQuestion < 8) timeBonus = 1.1;

                    // Calculate combined score
                    score.combinedScore = Math.round(percentageScore * timeBonus);
                }
                return score;
            });

            // Sort by combined score (highest first)
            allHighscores.sort((a, b) => b.combinedScore - a.combinedScore);

            // Display top 5 scores
            if (allHighscores.length === 0) {
                const row = document.createElement('tr');
                const cell = document.createElement('td');
                cell.colSpan = 4;
                cell.textContent = 'Nog geen highscores!';
                cell.style.textAlign = 'center';
                row.appendChild(cell);
                highscoreTable.appendChild(row);
            } else {
                allHighscores.slice(0, 5).forEach(score => {
                    const row = document.createElement('tr');

                    // Date cell with friendly format
                    const dateCell = document.createElement('td');
                    dateCell.textContent = formatFriendlyDate(score.date);
                    row.appendChild(dateCell);

                    // Tables cell
                    const tablesCell = document.createElement('td');
                    // Toon de tafels in een gebruiksvriendelijk formaat
                    const tafelNummers = score.tafelSet.split('-');
                    if (tafelNummers.length === 1) {
                        tablesCell.textContent = tafelNummers[0];
                    } else if (tafelNummers.length <= 3) {
                        tablesCell.textContent = tafelNummers.join(', ');
                    } else {
                        tablesCell.textContent = `${tafelNummers.length} tafels`;
                    }
                    row.appendChild(tablesCell);

                    // Score cell
                    const scoreCell = document.createElement('td');
                    const wrongAnswers = score.totalQuestions - score.score;
                    scoreCell.innerHTML = `<strong>${score.combinedScore}</strong><br><span style="font-size: 0.8rem; color: #43aa8b;">${score.score} goed</span> / <span style="font-size: 0.8rem; color: #ff6b6b;">${wrongAnswers} fout</span>`;
                    row.appendChild(scoreCell);

                    // Time cell
                    const timeCell = document.createElement('td');
                    timeCell.textContent = formatTime(score.time);
                    row.appendChild(timeCell);

                    // Add delete button
                    const actionCell = document.createElement('td');
                    const deleteButton = document.createElement('button');
                    deleteButton.className = 'delete-score-btn';
                    deleteButton.innerHTML = '×';
                    deleteButton.title = 'Verwijder score';
                    deleteButton.addEventListener('click', (e) => {
                        e.stopPropagation(); // Prevent event bubbling
                        deleteHighscore(score.tafelSet, score);
                    });
                    actionCell.appendChild(deleteButton);
                    row.appendChild(actionCell);

                    highscoreTable.appendChild(row);
                });
            }
        }

        function startGame() {
            isPaused = false;
            totalPausedTime = 0;

            selectionScreen.style.display = 'none';
            gameScreen.style.display = 'block';

            currentQuestion = 0;
            score = 0;
            currentStreak = 0;
            maxStreak = 0;

            generateQuestions();

            totalQuestionsElement.textContent = questionCount;
            currentScoreElement.textContent = score;

            initializeStars();

            document.getElementById('streakCounter').textContent = `Reeks: ${currentStreak}`;

            startTime = new Date();
            timerInterval = setInterval(updateTimer, 1000);

            showQuestion();
        }

        function generateQuestions() {
            questions = [];
            currentTafelSet = [...selectedTables]; // Make a copy

            for (let i = 0; i < questionCount; i++) {
                const tafel = selectedTables[Math.floor(Math.random() * selectedTables.length)];
                const number = Math.floor(Math.random() * 10) + 1;
                const answer = tafel * number;

                // Generate 3 wrong answers
                let wrongAnswers = [];
                while (wrongAnswers.length < 3) {
                    // Generate random answers close to correct one
                    let wrongAnswer;
                    if (Math.random() < 0.5) {
                        // Offset by small amount
                        wrongAnswer = answer + (Math.floor(Math.random() * 5) + 1);
                    } else {
                        // Offset by small amount
                        wrongAnswer = answer - (Math.floor(Math.random() * 5) + 1);
                    }

                    // Make sure wrong answer is positive and not the correct answer
                    if (wrongAnswer > 0 && wrongAnswer !== answer && !wrongAnswers.includes(wrongAnswer)) {
                        wrongAnswers.push(wrongAnswer);
                    }
                }

                questions.push({
                    tafel,
                    number,
                    answer,
                    wrongAnswers
                });
            }
        }

        function showQuestion() {
            if (currentQuestion >= questionCount) {
                endGame();
                return;
            }

            const question = questions[currentQuestion];

            // Generate random colors for the numbers
            const getRandomColor = () => {
                const colors = [
                    '#FF6B6B', // rood
                    '#4ECDC4', // turquoise
                    '#FF9A3C', // oranje
                    '#43AA8B', // groen
                    '#9B5DE5', // paars
                    '#F15BB5', // roze
                    '#00BBF9', // blauw
                    '#00F5D4', // mint
                    '#FEE440', // geel
                    '#9B2226'  // donkerrood
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            };

            // Add random emoji to the question
            const emojis = ['🦄', '🌈', '🌟', '🦋', '🐱', '🐶', '🦁', '🐼', '🐰', '🦊', '🐻', '🐯'];
            const randomEmoji = emojis[Math.floor(Math.random() * emojis.length)];

            // Create colorful question with each number in a different color
            const firstNumberColor = getRandomColor();
            const secondNumberColor = getRandomColor();
            const multiplyColor = getRandomColor();
            const equalsColor = getRandomColor();

            questionElement.innerHTML = `${randomEmoji} <span style="color: ${firstNumberColor};">${question.number}</span> <span style="color: ${multiplyColor};">×</span> <span style="color: ${secondNumberColor};">${question.tafel}</span> <span style="color: ${equalsColor};">=</span> `;

            // Clear previous options
            optionsElement.innerHTML = '';

            // Create answer options (1 correct, 3 wrong, in random order)
            const allAnswers = [question.answer, ...question.wrongAnswers];

            // Shuffle answers
            for (let i = allAnswers.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [allAnswers[i], allAnswers[j]] = [allAnswers[j], allAnswers[i]];
            }

            // Create buttons for each answer
            allAnswers.forEach(answer => {
                const button = document.createElement('button');
                button.textContent = answer;
                button.classList.add('option');

                // Add a random background color to each answer option
                const answerColor = getRandomColor();
                button.style.backgroundColor = answerColor;

                // Ensure text is always readable by using white text
                button.style.color = 'white';

                button.addEventListener('click', () => checkAnswer(answer));
                optionsElement.appendChild(button);
            });

            // Update progress bar
            const progressPercentage = (currentQuestion / questionCount) * 100;
            progressBar.style.width = `${progressPercentage}%`;

            // Hide previous result message
            resultMessageElement.classList.remove('show');
            emojiElement.textContent = '';
        }

        function checkAnswer(selectedAnswer) {
            const question = questions[currentQuestion];
            const isCorrect = selectedAnswer === question.answer;

            if (isCorrect) {
                score++;
                currentStreak++;
                maxStreak = Math.max(maxStreak, currentStreak);

                // Voeg de tafel toe aan correctTablesPlayed als het antwoord goed is
                gameStats.correctTablesPlayed.add(question.tafel);

                questionElement.classList.add('animate-correct');
                setTimeout(() => {
                    questionElement.classList.remove('animate-correct');
                }, 500);

                const goodMessages = [
                    'Goed gedaan! 🎉',
                    'Super! 🌟',
                    'Helemaal goed! 👏',
                    'Knap hoor! 🦄',
                    'Fantastisch! 🌈'
                ];
                const randomMessage = goodMessages[Math.floor(Math.random() * goodMessages.length)];
                resultMessageElement.textContent = randomMessage;
                resultMessageElement.classList.remove('wrong');
                resultMessageElement.classList.add('correct', 'show');

                const happyEmojis = ['😃', '🤩', '😊', '🥳', '😎', '👍', '💪', '🦸‍♀️'];
                emojiElement.textContent = happyEmojis[Math.floor(Math.random() * happyEmojis.length)];

                if (currentStreak > 0 && currentStreak % 5 === 0) {
                    resultMessageElement.textContent = `SUPER REEKS: ${currentStreak} op rij! 🔥`;
                }
            } else {
                currentStreak = 0;
                resultMessageElement.textContent = `Oeps! Het juiste antwoord is ${question.answer}`;
                resultMessageElement.classList.remove('correct');
                resultMessageElement.classList.add('wrong', 'show');

                const tryAgainEmojis = ['😕', '🤔', '🙂', '💭', '📚', '✏️'];
                emojiElement.textContent = tryAgainEmojis[Math.floor(Math.random() * tryAgainEmojis.length)];
            }

            currentScoreElement.textContent = score;
            document.getElementById('streakCounter').textContent = `Reeks: ${currentStreak}`;

            updateStars();

            setTimeout(() => {
                currentQuestion++;
                showQuestion();
            }, 1500);
        }

        function updateTimer() {
            if (!isPaused) {
                const elapsedSeconds = Math.floor(((new Date() - startTime) - totalPausedTime) / 1000);
                timerElement.textContent = `Tijd: ${elapsedSeconds} seconden`;
            }
        }

        function endGame() {
            clearInterval(timerInterval);
            const elapsedTime = Math.floor((Date.now() - startTime - totalPausedTime) / 1000);

            // Bereken scores en update stats
            const percentageScore = Math.round((score / questionCount) * 100);
            const avgTimePerQuestion = elapsedTime / questionCount;

            // Update perfect score streak - properly reset when not 100%
            if (percentageScore === 100) {
                gameStats.perfectScoreStreak = (gameStats.perfectScoreStreak || 0) + 1;
                console.log('Perfect score! Streak increased to:', gameStats.perfectScoreStreak);
            } else {
                gameStats.perfectScoreStreak = 0;
                console.log('Not a perfect score. Streak reset to 0');
            }

            // Update game statistieken
            gameStats.totalQuestions = questionCount;
            gameStats.lastSelectedTables = [...selectedTables]; // Sla de geselecteerde tafels op
            updateGameStats();

            // Check voor nieuwe badges
            checkAndAwardBadges();

            // Determine time bonus
            let timeBonus = 1.0;
            let timeBonusText = "";

            if (avgTimePerQuestion < 3) {
                timeBonus = 1.5;
                timeBonusText = "Supersnel! (1.5×)";
            } else if (avgTimePerQuestion < 5) {
                timeBonus = 1.3;
                timeBonusText = "Heel snel! (1.3×)";
            } else if (avgTimePerQuestion < 8) {
                timeBonus = 1.1;
                timeBonusText = "Snel! (1.1×)";
            } else {
                timeBonusText = "Goed tempo (1.0×)";
            }

            // Calculate combined score
            const combinedScore = Math.round(percentageScore * timeBonus);

            // Update the result screen
            document.getElementById('finalScore').textContent = `${score}/${questionCount}`;
            document.getElementById('finalTime').textContent = formatTime(elapsedTime);
            document.getElementById('percentageScore').textContent = `${percentageScore}%`;
            document.getElementById('timeBonus').textContent = timeBonusText;
            document.getElementById('combinedScore').textContent = `${combinedScore}`;

            // Show appropriate emoji based on score
            const resultEmoji = document.getElementById('resultEmoji');
            if (percentageScore === 100) {
                resultEmoji.textContent = '🏆';
                // Toon confetti bij een perfecte score
                createConfetti();
            } else if (percentageScore >= 90) {
                resultEmoji.textContent = '🌟';
            } else if (percentageScore >= 80) {
                resultEmoji.textContent = '😃';
            } else if (percentageScore >= 70) {
                resultEmoji.textContent = '🙂';
            } else if (percentageScore >= 50) {
                resultEmoji.textContent = '😐';
            } else {
                resultEmoji.textContent = '😢';
            }

            // Save highscore
            const tableKey = selectedTables.sort().join('-');
            let highscores = JSON.parse(localStorage.getItem(`highscores-${tableKey}`)) || [];

            const newHighscore = {
                date: new Date().toISOString(), // Store as ISO string for better date handling
                tables: tableKey,
                score: score,
                totalQuestions: questionCount,
                time: elapsedTime,
                combinedScore: combinedScore,
                maxStreak: maxStreak
            };

            highscores.push(newHighscore);
            localStorage.setItem(`highscores-${tableKey}`, JSON.stringify(highscores));

            // Update highscore table
            updateHighscoreTable();

            // Show result screen
            gameScreen.style.display = 'none';
            resultScreen.style.display = 'flex';
        }

        function initializeStars() {
            const starsContainer = document.getElementById('starsContainer');
            starsContainer.innerHTML = '';

            // Voeg 5 sterren toe (of een ander aantal afhankelijk van de moeilijkheidsgraad)
            for (let i = 0; i < 5; i++) {
                const star = document.createElement('div');
                star.className = 'star';
                star.innerHTML = '★';
                star.id = `star-${i}`;
                starsContainer.appendChild(star);
            }
        }

        function updateStars() {
            // Bereken hoeveel sterren verdiend zijn op basis van score percentage
            const percentage = (score / currentQuestion) * 100;
            const starsEarned = Math.floor(percentage / 20); // 5 sterren = 100%, 4 sterren = 80%, etc.

            // Update sterren UI
            for (let i = 0; i < 5; i++) {
                const star = document.getElementById(`star-${i}`);
                if (i < starsEarned) {
                    if (!star.classList.contains('earned')) {
                        star.classList.add('earned');
                    }
                } else {
                    star.classList.remove('earned');
                }
            }
        }

        function createConfetti() {
            const colors = ['#ff0000', '#00ff00', '#0000ff', '#ffff00', '#ff00ff', '#00ffff'];

            for (let i = 0; i < 100; i++) {
                setTimeout(() => {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';

                    // Willekeurige positie, kleur en grootte
                    const size = Math.random() * 10 + 5;
                    const color = colors[Math.floor(Math.random() * colors.length)];

                    confetti.style.width = `${size}px`;
                    confetti.style.height = `${size}px`;
                    confetti.style.backgroundColor = color;
                    confetti.style.left = `${Math.random() * 100}vw`;
                    confetti.style.top = '-20px';
                    confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '0';
                    confetti.style.opacity = '1';

                    document.body.appendChild(confetti);

                    // Animeer het confetti
                    const animationDuration = Math.random() * 3 + 2;
                    confetti.style.transition = `top ${animationDuration}s linear, left ${animationDuration}s ease-in-out, opacity ${animationDuration}s linear`;

                    setTimeout(() => {
                        confetti.style.top = '100vh';
                        confetti.style.left = `${Math.random() * 100}vw`;
                        confetti.style.opacity = '0';

                        // Verwijder het confetti element na de animatie
                        setTimeout(() => {
                            document.body.removeChild(confetti);
                        }, animationDuration * 1000);
                    }, 10);
                }, i * 50);
            }
        }

        // Helper functions
        function formatTime(seconds) {
            const minutes = Math.floor(seconds / 60);
            const remainingSeconds = seconds % 60;
            return `${minutes}:${remainingSeconds.toString().padStart(2, '0')}`;
        }

        function deleteHighscore(tafelSet, scoreToDelete) {
            if (confirm('Weet je zeker dat je deze score wilt verwijderen?')) {
                // Get the current highscores for this table set
                const highscores = JSON.parse(localStorage.getItem(`highscores-${tafelSet}`)) || [];

                // Find the index of the score to delete
                // We need to match based on date, score, and time since we don't have a unique ID
                const index = highscores.findIndex(score =>
                    score.date === scoreToDelete.date &&
                    score.score === scoreToDelete.score &&
                    score.time === scoreToDelete.time &&
                    score.totalQuestions === scoreToDelete.totalQuestions
                );

                if (index !== -1) {
                    // Remove the score
                    highscores.splice(index, 1);

                    // Save back to localStorage
                    localStorage.setItem(`highscores-${tafelSet}`, JSON.stringify(highscores));

                    // Update the highscore table
                    updateHighscoreTable();
                }
            }
        }

        function pauseGame() {
            if (!isPaused) {
                isPaused = true;
                pauseStartTime = new Date();
                clearInterval(timerInterval);
                pauseMenu.style.display = 'flex';
                pauseButton.style.display = 'none'; // Verberg de pauzeknop tijdens pauze
            }
        }

        function resumeGame() {
            if (isPaused) {
                // Bereken hoelang het spel gepauzeerd was
                const pauseDuration = new Date() - pauseStartTime;
                totalPausedTime += pauseDuration;

                isPaused = false;
                pauseMenu.style.display = 'none';
                pauseButton.style.display = 'flex'; // Toon de pauzeknop weer

                // Herstart de timer
                timerInterval = setInterval(updateTimer, 1000);
                updateTimer(); // Update meteen
            }
        }

        function quitGame() {
            // Stop de timer
            clearInterval(timerInterval);

            // Verberg het spel en pauzemenu
            gameScreen.style.display = 'none';
            pauseMenu.style.display = 'none';

            // Reset de pauze status
            isPaused = false;
            totalPausedTime = 0;

            // Reset de geselecteerde tafels en vraagaantal
            tafelButtons.forEach(button => {
                button.classList.remove('selected');
            });
            questionCountButtons.forEach(button => {
                button.classList.remove('selected');
            });
            selectedTables = [];
            questionCount = 0;

            // Update de start knop status
            updateStartButtonState();

            // Toon het selectiescherm en update de highscore tabel
            selectionScreen.style.display = 'block';
            updateHighscoreTable();
        }

        function showScreen(screenId) {
            // Verberg alle schermen
            document.querySelectorAll('.screen-section').forEach(screen => {
                screen.style.display = 'none';
            });

            // Toon het gewenste scherm met de juiste display stijl
            const screen = document.getElementById(screenId);
            switch (screenId) {
                case 'badgesScreen':
                    screen.style.display = 'block';
                    break;
                case 'selectionScreen':
                    screen.style.display = 'block';
                    break;
                case 'gameScreen':
                case 'resultScreen':
                    screen.style.display = 'flex';
                    break;
            }

            // Update badges als we naar het badge scherm gaan
            if (screenId === 'badgesScreen') {
                updateBadgesDisplay();
            }
        }

        function updateBadgesDisplay() {
            const badgesGrid = document.getElementById('badgesGrid');
            badgesGrid.innerHTML = '';

            // Log voor debugging
            console.log('Current gameStats:', {
                gamesPlayed: gameStats.gamesPlayed,
                uniqueTablesPlayed: Array.from(gameStats.uniqueTablesPlayed),
                correctTablesPlayed: Array.from(gameStats.correctTablesPlayed),
                fastestGame: gameStats.fastestGame,
                highestStreak: gameStats.highestStreak
            });
            console.log('Current earnedBadges:', earnedBadges);
            console.log('All badges:', Object.values(BADGES).map(b => b.title));

            Object.values(BADGES).forEach(badge => {
                const isEarned = earnedBadges[badge.id];
                const stats = calculateCurrentStats();
                const progress = badge.progress(stats);

                console.log(`Badge ${badge.title}:`, {
                    isEarned,
                    progress,
                    stats: {
                        avgTimePerQuestion: stats.avgTimePerQuestion,
                        percentageScore: stats.percentageScore,
                        maxStreak: stats.maxStreak,
                        uniqueTablesPlayed: Array.from(stats.uniqueTablesPlayed),
                        correctTablesPlayed: Array.from(stats.correctTablesPlayed),
                        gamesPlayed: stats.gamesPlayed
                    }
                });

                const badgeElement = document.createElement('div');
                badgeElement.className = `badge ${isEarned ? '' : 'locked'}`;
                badgeElement.innerHTML = `
                    <div class="badge-icon">${badge.icon}</div>
                    <div class="badge-title">${badge.title}</div>
                    <div class="badge-description">${badge.description}</div>
                `;
                badgesGrid.appendChild(badgeElement);
            });
        }

        function showBadgeNotification(badge) {
            const notification = document.getElementById('badgeNotification');
            notification.innerHTML = `
                <div style="font-size: 2em">${badge.icon}</div>
                <div><strong>Nieuwe badge ontgrendeld!</strong></div>
                <div>${badge.title}</div>
            `;
            notification.style.display = 'block';

            setTimeout(() => {
                notification.style.display = 'none';
            }, 3000);
        }

        function calculateCurrentStats() {
            // Als er nog geen spel is gespeeld
            if (!startTime) {
                return {
                    avgTimePerQuestion: Infinity,
                    percentageScore: 0,
                    maxStreak: gameStats.highestStreak || 0,
                    uniqueTablesPlayed: gameStats.uniqueTablesPlayed,
                    correctTablesPlayed: gameStats.correctTablesPlayed,
                    gamesPlayed: gameStats.gamesPlayed,
                    perfectScoreStreak: gameStats.perfectScoreStreak || 0,
                    lastSelectedTables: gameStats.lastSelectedTables || [],
                    totalQuestions: gameStats.totalQuestions || 0
                };
            }

            // Calculate elapsed time excluding paused time
            const elapsedTime = (Date.now() - startTime - totalPausedTime) / 1000;

            // Calculate average time per question using current question count
            // If no questions answered yet, return Infinity to avoid division by zero
            const avgTimePerQuestion = currentQuestion > 0 ? elapsedTime / (currentQuestion + 1) : Infinity;

            return {
                avgTimePerQuestion,
                percentageScore: Math.round((score / questionCount) * 100),
                maxStreak: Math.max(maxStreak, gameStats.highestStreak || 0),
                uniqueTablesPlayed: gameStats.uniqueTablesPlayed,
                correctTablesPlayed: gameStats.correctTablesPlayed,
                gamesPlayed: gameStats.gamesPlayed,
                perfectScoreStreak: gameStats.perfectScoreStreak || 0,
                lastSelectedTables: selectedTables, // Gebruik de huidige geselecteerde tafels tijdens het spel
                totalQuestions: questionCount
            };
        }

        function checkAndAwardBadges() {
            const stats = calculateCurrentStats();

            Object.values(BADGES).forEach(badge => {
                if (!earnedBadges[badge.id] && badge.condition(stats)) {
                    earnedBadges[badge.id] = true;
                    localStorage.setItem('earnedBadges', JSON.stringify(earnedBadges));
                    showBadgeNotification(badge);
                }
            });
        }

        function updateGameStats() {
            gameStats.gamesPlayed++;
            selectedTables.forEach(table => gameStats.uniqueTablesPlayed.add(table));

            const gameTime = (Date.now() - startTime - totalPausedTime) / 1000;
            if (gameTime < gameStats.fastestGame) {
                gameStats.fastestGame = gameTime;
            }

            if (maxStreak > gameStats.highestStreak) {
                gameStats.highestStreak = maxStreak;
            }

            // Convert Sets to Arrays for localStorage
            const statsForStorage = {
                ...gameStats,
                uniqueTablesPlayed: Array.from(gameStats.uniqueTablesPlayed),
                correctTablesPlayed: Array.from(gameStats.correctTablesPlayed),
                perfectScoreStreak: gameStats.perfectScoreStreak || 0,
                lastSelectedTables: [...selectedTables] // Sla de huidige geselecteerde tafels op
            };
            localStorage.setItem('gameStats', JSON.stringify(statsForStorage));
        }

        // Voeg een reset functie toe voor het badge systeem
        function resetBadges() {
            if (confirm('Weet je zeker dat je alle badges wilt resetten?')) {
                earnedBadges = {};
                gameStats = {
                    gamesPlayed: 0,
                    uniqueTablesPlayed: new Set(),
                    correctTablesPlayed: new Set(),
                    fastestGame: Infinity,
                    highestStreak: 0
                };
                localStorage.setItem('earnedBadges', JSON.stringify(earnedBadges));
                localStorage.setItem('gameStats', JSON.stringify({
                    ...gameStats,
                    uniqueTablesPlayed: [],
                    correctTablesPlayed: []
                }));
                updateBadgesDisplay();
            }
        }
    </script>
</body>
</html>